{"version":3,"sources":["InAppUpdates.android.ts"],"names":["SpInAppUpdates","NativeModules","SpInAppUpdatesOrEmpty","InAppUpdates","InAppUpdatesBase","constructor","event","resultListeners","emitEvent","bytesDownloaded","totalBytesToDownload","status","parseInt","statusUpdateListeners","callback","addListener","hasListeners","setStatusUpdateSubscription","removeListener","checkOptions","curVersion","toSemverConverter","customVersionComparator","appVersion","debugLog","checkNeedsUpdate","then","inAppUpdateInfo","updateAvailability","versionCode","AndroidAvailabilityStatus","AVAILABLE","newAppV","throwError","vCompRes","shouldUpdate","storeVersion","other","reason","DEVELOPER_TRIGGERED","catch","err","updateOptions","updateType","AndroidUpdateType","FLEXIBLE","IMMEDIATE","startUpdate","installUpdate","eventEmitter","NativeEventEmitter","IN_APP_UPDATE_STATUS_KEY","onIncomingNativeStatusUpdate","IN_APP_UPDATE_RESULT_KEY","onIncomingNativeResult"],"mappings":"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","sourcesContent":["import { NativeModules, NativeEventEmitter } from 'react-native';\nimport { getVersion } from 'react-native-device-info';\n\nimport { compareVersions } from './utils';\nimport {\n  StatusUpdateEvent,\n  CheckOptions,\n  InstallationResult,\n  AndroidInAppUpdateExtras,\n  AndroidStatusEventListener,\n  AndroidIntentResultListener,\n  AndroidStartUpdateOptions,\n  AndroidAvailabilityStatus,\n  AndroidUpdateType,\n  AndroidNeedsUpdateResponse,\n} from './types';\nimport InAppUpdatesBase from './InAppUpdatesBase';\n\nconst { SpInAppUpdates } = NativeModules;\nconst SpInAppUpdatesOrEmpty: {\n  IN_APP_UPDATE_STATUS_KEY: any;\n  IN_APP_UPDATE_RESULT_KEY: any;\n} = SpInAppUpdates || {};\n\nexport default class InAppUpdates extends InAppUpdatesBase {\n  constructor() {\n    super();\n    this.eventEmitter = new NativeEventEmitter(SpInAppUpdates);\n    this.eventEmitter.addListener(\n      SpInAppUpdatesOrEmpty?.IN_APP_UPDATE_STATUS_KEY,\n      this.onIncomingNativeStatusUpdate\n    );\n    this.eventEmitter.addListener(\n      SpInAppUpdatesOrEmpty?.IN_APP_UPDATE_RESULT_KEY,\n      this.onIncomingNativeResult\n    );\n  }\n\n  protected onIncomingNativeResult = (event: InstallationResult) => {\n    this.resultListeners.emitEvent(event);\n  };\n\n  protected onIncomingNativeStatusUpdate = (event: StatusUpdateEvent) => {\n    let { bytesDownloaded, totalBytesToDownload, status } = event;\n    // This data comes from Java as a string, since React's WriteableMap doesn't support `long` type values.\n    bytesDownloaded = parseInt(bytesDownloaded, 10);\n    totalBytesToDownload = parseInt(totalBytesToDownload, 10);\n    status = parseInt(`${status}`, 10);\n    this.statusUpdateListeners.emitEvent({\n      ...event,\n      bytesDownloaded,\n      totalBytesToDownload,\n      status,\n    });\n  };\n\n  public addStatusUpdateListener = (callback: AndroidStatusEventListener) => {\n    this.statusUpdateListeners.addListener(callback);\n    if (this.statusUpdateListeners.hasListeners()) {\n      SpInAppUpdates.setStatusUpdateSubscription(true);\n    }\n  };\n\n  public removeStatusUpdateListener = (\n    callback: AndroidStatusEventListener\n  ) => {\n    this.statusUpdateListeners.removeListener(callback);\n    if (!this.statusUpdateListeners.hasListeners()) {\n      SpInAppUpdates.setStatusUpdateSubscription(false);\n    }\n  };\n\n  public addIntentSelectionListener = (\n    callback: AndroidIntentResultListener\n  ) => {\n    this.resultListeners.addListener(callback);\n  };\n\n  public removeIntentSelectionListener = (\n    callback: AndroidIntentResultListener\n  ) => {\n    this.resultListeners.removeListener(callback);\n  };\n\n  /**\n   * Checks if there are any updates available.\n   */\n  public checkNeedsUpdate = (\n    checkOptions?: CheckOptions\n  ): Promise<AndroidNeedsUpdateResponse> => {\n    const { curVersion, toSemverConverter, customVersionComparator } =\n      checkOptions || {};\n\n    let appVersion: string;\n    if (curVersion) {\n      appVersion = curVersion;\n    } else {\n      appVersion = getVersion();\n    }\n    this.debugLog('Checking store version (Android)');\n    return SpInAppUpdates.checkNeedsUpdate()\n      .then((inAppUpdateInfo: AndroidInAppUpdateExtras) => {\n        const { updateAvailability, versionCode } = inAppUpdateInfo || {};\n        if (updateAvailability === AndroidAvailabilityStatus.AVAILABLE) {\n          let newAppV = `${versionCode}`;\n          if (toSemverConverter) {\n            newAppV = toSemverConverter(versionCode);\n            this.debugLog(\n              `Used custom semver, and converted result from store (${versionCode}) to ${newAppV}`\n            );\n            if (!newAppV) {\n              this.throwError(\n                `Couldnt convert ${versionCode} using your custom semver converter`,\n                'checkNeedsUpdate'\n              );\n            }\n          }\n          const vCompRes = customVersionComparator\n            ? customVersionComparator(newAppV, appVersion)\n            : compareVersions(newAppV, appVersion);\n\n          if (vCompRes > 0) {\n            this.debugLog(\n              `Compared cur version (${curVersion}) with store version (${newAppV}). The store version is higher!`\n            );\n            // play store version is higher than the current version\n            return {\n              shouldUpdate: true,\n              storeVersion: newAppV,\n              other: { ...inAppUpdateInfo },\n            };\n          }\n          this.debugLog(\n            `Compared cur version (${curVersion}) with store version (${newAppV}). The current version is higher!`\n          );\n          return {\n            shouldUpdate: false,\n            storeVersion: newAppV,\n            reason: `current version (${curVersion}) is already later than the latest store version (${newAppV}${\n              toSemverConverter ? ` - originated from ${versionCode}` : ''\n            })`,\n            other: { ...inAppUpdateInfo },\n          };\n        } else if (\n          updateAvailability === AndroidAvailabilityStatus.DEVELOPER_TRIGGERED\n        ) {\n          this.debugLog('Update has already been triggered by the developer');\n        } else {\n          this.debugLog(\n            `Failed to fetch a store version, status: ${updateAvailability}`\n          );\n        }\n\n        return {\n          shouldUpdate: false,\n          reason: `status: ${updateAvailability} means there's no new version available`,\n          other: { ...inAppUpdateInfo },\n        };\n      })\n      .catch((err: any) => {\n        this.debugLog(err);\n        this.throwError(err, 'checkNeedsUpdate');\n      });\n  };\n\n  /**\n   *\n   * Shows pop-up asking user if they want to update, giving them the option to download said update.\n   */\n  public startUpdate = (\n    updateOptions: AndroidStartUpdateOptions\n  ): Promise<void> => {\n    const { updateType } = updateOptions || {};\n    if (\n      updateType !== AndroidUpdateType.FLEXIBLE &&\n      updateType !== AndroidUpdateType.IMMEDIATE\n    ) {\n      this.throwError(\n        `updateType should be one of: ${AndroidUpdateType.FLEXIBLE} or ${AndroidUpdateType.IMMEDIATE}, ${updateType} was passed.`,\n        'startUpdate'\n      );\n    }\n    return SpInAppUpdates.startUpdate(updateType).catch((err: any) => {\n      this.throwError(err, 'startUpdate');\n    });\n  };\n\n  public installUpdate = (): void => {\n    SpInAppUpdates.installUpdate();\n  };\n}\n"]}